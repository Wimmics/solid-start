<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Solid indexing</title>
  <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove" defer></script>
  <script class="remove">
    // All config options at https://respec.org/docs/
    var respecConfig = {
      specStatus: "ED",
      editors: [{ name: "Your Name", url: "https://your-site.com" }],
      github: "some-org/mySpec",
      shortName: "dahut",
      xref: "web-platform",
      group: "my-working-group",
    };
  </script>
</head>

<body>
  <section id="abstract">
    <p>With Solid data is distributed accross storages. Depending on the use cases, a client application can search for
      data in one or several storage(s). This document describes some mechanisms to index data on Solid storages
      that client-side or [=server-side applications=] can use to allow faster
      searching. As the Solid server does not need to know about these indexes, editors of application should define the
      indexes they are using in their [=client to client protocol=].</p>
  </section>

  <section id="sotd">
    <p>This document is a result of a collaboration between INRIA and Startin'Blox about a research project on indexing
      in a Solid ecosystem.</p>
  </section>

  <section class="informative">
    <h2>Introduction</h2>

    <p>Indexes are a well kwnow mechanism that allow faster searching. Indeed, an index...</p>

    <section>
      <h3>Terminology</h3>

      <p>
        <dfn>server-side application</dfn>
        TBD.
      </p>

      <p>
        <dfn>client to client protocol</dfn>
        TBD.
      </p>
    </section>

    <section>
      <h3>Namespaces</h3>

      TBD.
    </section>
  </section>

  <section>
    <h2>Indexes</h2>

    <section>
      <h3>Instance indexes</h3>
  
      <section>
        <h4>Property-value indexes</h4>

        <aside class="example">
          <pre>
            : a ex:Index;
              ex:forProperty schema:property;
              ex:forValue "some value";
              ex:instance 
                &lt;path/to/an/instance&gt; 
                &lt;path/to/a/second/instance&gt;.
          </pre>
          <p>Instead of using the <code>ex:instance</code> predicate do we annotate indices directly like:</p>
          <pre>
            &lt;&gt; a ex:Index.

            &lt;path/to/an/instance&gt a ex:IndexEntry;
              ex:forProperty schema:property1;
              ex:forValue "some value".

            &lt;path/to/a/second/instance&gt a ex:IndexEntry;
              ex:forProperty schema:property2;
              ex:forValue "some value".
          </pre>

          <p>With a shape:</p>
          <pre>
            &lt;&gt; a ex:Index.

            &lt;path/to/an/instance&gt a ex:IndexEntry;
              ex:hasShape [
                sh:property [
                  sh:path schema:property1;
                  sh:hasValue "some value"
                ]
              ].

            &lt;path/to/a/second/instance&gt a ex:IndexEntry;
              ex:hasShape [
                sh:property [
                  sh:path schema:property2;
                  sh:hasValue "some value"
                ]
              ].
          </pre>
        </aside>

        <p>
          When the same property is indexed in the whole index, the <code>ex:forProperty</code> predicate can be defined in the index itself like:
          <aside class="example">
            <pre>
              &lt;&gt; a ex:Index;
                ex:forProperty schema:property.

              &lt;path/to/an/instance&gt a ex:IndexEntry;
                ex:forValue "some value".

              &lt;path/to/a/second/instance&gt a ex:IndexEntry;
                ex:forValue "some value".
            </pre>
          </aside>
        </p>
      </section>

      <section>
        <h4>SKOS indexes</h4>

        <aside class="example">
          <pre>
            &lt;&gt; a ex:Index.

            &lt;path/to/an/instance&gt a ex:IndexEntry;
              ex:mentions schema:someSkosConcept.

            &lt;path/to/a/second/instance&gt a ex:IndexEntry;
              ex:mentions schema:someOtherSkosConcept.
          </pre>

          <p>With shape:</p>
          <pre>
            &lt;&gt; a ex:Index.

            &lt;path/to/an/instance&gt a ex:IndexEntry;
              ex:hasShape [
                sh:property [
                  sh:path schema:property1;
                  sh:hasValue schema:someSkosConcept
                ]
              ].

            &lt;path/to/a/second/instance&gt a ex:IndexEntry;
              ex:hasShape [
                sh:property [
                  sh:path schema:property2;
                  sh:hasValue schema:someOtherSkosConcept
                ]
              ].
          </pre>
        </aside>
      </section>

      <section>
        <h4>String indexes</h4>

        <p>
          <aside class="example">
            <pre>
              &lt;&gt; a ex:Index.

              &lt;path/to/an/instance&gt a ex:IndexEntry;
                ex:hasShape [
                  sh:property [
                    sh:path schema:property1;
                    sh:pattern "a.*"
                  ]
                ].

              &lt;path/to/a/second/instance&gt a ex:IndexEntry;
                ex:hasShape [
                  sh:property [
                    sh:path schema:property2;
                    sh:pattern "a.*"
                  ]
                ].
            </pre>
          </aside>
        </p>
      </section>
    </section>

    <section>
      <h3>Meta indexes</h3>
    
      <section>
        <h4>Source selection indexes</h4>

        <aside class="example">
          <pre>
            &lt;&gt; a ex:Index.

            &lt;path/to/an/instance&gt a ex:IndexEntry;
              ex:hasShape _:b1;
              ex:hasCount 8.

            &lt;path/to/a/second/instance&gt a ex:IndexEntry;
              ex:hasShape _:b1;
              ex:hasCount 25.

            _:b1 a sh:NodeShape;
              sh:property [
                sh:path schema:property1;
                sh:hasValue "some value"
              ].
          </pre>

          <p>Using a <code>sh:ValidationResult</code>:</p>
          <pre>
            &lt;&gt; a ex:Index.

            &lt;path/to/an/instance&gt a ex:IndexEntry;
              ex:hasShape _:b1;
              ex:hasValidationResult [
                a sh:ValidationResult;
                sh:minCount 8;
                sh:maxCount 8;
              ].

            &lt;path/to/a/second/instance&gt a ex:IndexEntry;
              ex:hasShape _:b1;
              ex:hasValidationResult [
                a sh:ValidationResult;
                sh:minCount 25;
                sh:maxCount 25;
              ].

            _:b1 a sh:NodeShape;
              sh:property [
                sh:path schema:property1;
                sh:hasValue "some value"
              ].
          </pre>
        </aside>
      </section>
  </section>

  </section>

  <section>
    <h2>Indexing a single storage</h2>

  </section>

  <section>
    <h2>Indexing multiple storages</h2>

    <section>
      <h3>Using distributed indexes</h3>
    </section>

    <section>
      <h3>Using federated indexes</h3>
    </section>

    <section>
      <h3>Using hybrid indexes</h3>
    </section>

  </section>

  <section>
    <h2>Discovery of indexes</h2>

  </section>

  <section>
    <h2>Querying indexes</h2>
  </section>
  <section id="conformance">
    <p>
      This is required for specifications that contain normative material.
    </p>
  </section>
</body>

</html>