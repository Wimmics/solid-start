<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Solid indexing</title>
  <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove" defer></script>
  <script class="remove">
    // All config options at https://respec.org/docs/
    var respecConfig = {
      specStatus: "ED",
      editors: [{ name: "Your Name", url: "https://your-site.com" }],
      github: "some-org/mySpec",
      shortName: "dahut",
      xref: "web-platform",
      group: "my-working-group",
    };
  </script>
</head>

<body>
  <section id="abstract">
    <p>With Solid data is distributed accross storages. Depending on the use cases, a client application can search for
      data in one or several storage(s). This document describes some mechanisms to index data on Solid storages
      that client-side or [=server-side applications=] can use to allow faster
      searching. As the Solid server does not need to know about these indexes, editors of application should define the
      indexes they are using in their [=client-to-client protocol=].</p>
  </section>

  <section id="sotd">
    <p>This document is a result of a collaboration between INRIA and Startin'Blox about a research project on indexing
      in a Solid ecosystem.</p>
  </section>

  <section class="informative">
    <h2>Introduction</h2>

    <p>The current Solid protocol (version 0.11.0) does not provide a built-in server mechanism to search for data. This
      is left to [=client-to-client protocols=]. This presents the advantage of keeping the Solid protocol as simple as
      possible. In this document we are proposing an indexing mechanism that stays in the perimeter of client-to-client
      protocols. Although any editor of application is free to define the mechanism of its choice we are proposing a
      generic vocabulary to do indexing. Using a common vocabulary is indeed encouraged to facilitate interoperability.
    </p>

    <p>Indexing is a largely used mechanism that allow to find data faster thanks to [=indexes=]. By querying
      the appropriate indexes one can avoid to browse the entire dataset to find a particular piece. This document tries
      to answer questions like who is indexing and how.</p>

    <p>Quelle genre de données voulons nous indexer?</p>

    <p>Parler des différents types d'indexation, single, multiple, fédéré, distribué...</p>

    <section>
      <h3>Terminology</h3>

      <p>
        <dfn data-lt="indexes">Index</dfn>
        TBD.
      </p>

      <p>
        <dfn>Server-side application</dfn>
        TBD.
      </p>

      <p>
        <dfn>Client-to-client protocol</dfn>
        TBD.
      </p>
    </section>

    <section>
      <h3>Namespaces</h3>

      <table>
        <tr>
          <th>Prefix</th>
          <th>Namespace</th>
          <th>Description</th>
        </tr>
        <tr>
          <td><code>idx</code></td>
          <td>https://ns.inria.fr/idx/terms#</td>
          <td>Indexing ontology</td>
        </tr>
        <tr>
          <td><code>sh</code></td>
          <td>https://www.w3.org/ns/shacl</td>
          <td>[[SHACL]]</td>
        </tr>
        <tr>
          <td><code>rdf</code></td>
          <td>http://www.w3.org/1999/02/22-rdf-syntax-ns#</td>
          <td>[[RDF-SCHEMA]]</td>
        </tr>
      </table>
    </section>
  </section>

  <section>
    <h2>Indexes</h2>

    <p>This document proposes the <a href="./ontology.ttl" alt="">Indexing ontology</a> as vocabulary for the indexes.
      This ontology is using [[SHACL]] shapes to
      express what is indexed.</p>

    <section>
      <h3>General indexes</h3>

      <p>An index is a RDF document [[RDF11-CONCEPTS]] of type <code>idx:Index</code> containing entries which point to
        instances conforming to a particular shape. The shape the index or an entry is targeting is expressed with the
        <code>idx:hasShape</code> predicate.
      </p>

      <p>An entry is of type <code>idx:IndexEntry</code> and targets a resource using the <code>idx:hasTarget</code>
        predicate. The resource the entry is targeting MUST conform to the shape of the index.</p>

      <p>For instance an index of people living in Paris could be expressed like in the example.</p>

      <aside id="example1" class="example" title="Index of people living in Paris.">
        <p>Alice and Bob are people indexed by this index because they are conforming to the shape of the index: they
          are instances of the <code>foaf:Person</code> class and have the value "Paris" set for the
          <code>schema:hasLocation</code> predicate.
        </p>
        <pre data-include="./example1.ttl" data-include-format='text' />
      </aside>

      <aside class="example" title='Index of people with a given name starting with "a".'>
        <pre data-include="./example3.ttl" data-include-format='text' />
      </aside>
    </section>

    <section>
      <h3>Indexing using the LDP structure</h3>

      <p>Indexing can be done with LDP when the folder structure has a defined meaning. For instance, messages of the
        [Solid chat] protocol are stored in a hierachy of date folder. Therefore this client rule can be used to find
        data faster. For instance one can find the messages from 2024 in the 2024 folder.</p>
    </section>

    <section>
      <h3>Meta indexes</h3>

      <p>Meta indexes are indexes that are indexing other indexes. They can be used to divide a entire index into
        smaller parts. While more queries are needed to load the data of interest, meta indexes might reduce the
        size of the transfered data by targeting parts with precision. It can also give faster results especially
        when combined with an heuristic like detailed in the next section.</p>

      <aside class="example"
        title="Meta index listing indexes having people living in Paris and Toulouse.">
        <pre data-include="./example2.ttl" data-include-format='text' />
      </aside>

      <section>
        <h4>Source selection</h4>

        <p>Source selection is a technique that consists in selecting indexes that are juged relevant in a bunch of indexes. 
          This way it's possible to get results faster. This technique relies on one or several heuristics. One example of 
          heuristic is the number of item that can be found in an index. Setting a minimun number of results might reduce the 
          number of selected indexes.</p>

        <p>When the data to be found is distributed across multiple indexes, one has to query each of them to complete.
          Without a source selection step before querying, there is no indication on which index to query: they
          are considered all equal. This can be very ineffiscient as some indexes without any valid results might be
          queried.</p>

        <aside class="example"
          title="A source selection index that lists the WebId of organizations having people living in Paris with an indication of how much people living in Paris each organization has.">
          <pre data-include="./example4.ttl" data-include-format='text' />
        </aside>
      </section>

      <section>
        <h4>Source ordering</h4>

        <p>Source ordering consists in querying the most relevant indexes first. This technique uses one or several 
          criterias to order the indexes. One example of a criteria is the number of results contained in an index. 
          If we take the previous example the <code>:entry2</code> index will be queried before the <code>:entry1</code> 
          index as it presents more results (the value of the <code>idx:hasCount</code> is higher).
        </p>

        <p>Source ordering can be used to get results faster as it introduces a priority level between indexes based on 
          some heuristic(s). Without source ordering results can be slower to come especially when relevant data is part 
          of an index that is at the end of the querying queue.
        </p>
      </section>

    </section>

    <section>
      <h3>Sorting the index entries</h3>

      <p>MUST use RDF lists.</p>
    </section>

    <section>
      <h3>Pagination</h3>

      <p>Use [[LDP-Paging]]</p>
    </section>

  </section>

  <section>
    <h2>Indexing strategies</h2>

    <section>
      <h3>Indexed data</h3>

      <p>While we can use indexes to find data on a single storage, they can also be used to find data accross multiple
        storages. This kind of indexing can be used for example to index people having their own storage. </p>

      <section>
        <h4>Indexing a single storage</h4>
      </section>

      <section>
        <h4>Indexing multiple storages</h4>
      </section>
    </section>

    <section>
      <h3>Using distributed indexes</h3>

      <p>When indexes are only present on each storage we talk about distributed indexing.</p>
    </section>

    <section>
      <h3>Using federated indexes</h3>

      <p></p>
    </section>

    <section>
      <h3>Using hybrid indexes</h3>
    </section>

  </section>

  </section>

  <section>
    <h2>Discovery of indexes</h2>

    <p>Indexes can be discovered by any means. However implementers SHOULD use the mechanisms recommened by the
      client-to-client protocol if any.</p>

    <p>A possible discovery mean is Type Indexes. They are a well known mechanism used by applications implementing the
      [[Solid-protocol]].</p>
  </section>

  <section>
    <h2>Querying indexes</h2>

    <p>Comunica can be used with streams.</p>
  </section>

  <section>
    <h2>Relation to Solid Type indexes</h2>

    <p>Solid Type Indexes are designed to...</p>
  </section>

  <section id="conformance">
    <p>
      This is required for specifications that contain normative material.
    </p>
  </section>
</body>

</html>